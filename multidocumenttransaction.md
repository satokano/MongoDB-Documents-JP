[2018年6月27日にMat KeepとAlyson Cabralによって公開されたブログ](https://www.mongodb.com/blog/post/mongodb-multi-document-acid-transactions-general-availability)の翻訳

----

# MongoDB Multi-Document ACID Transactions are GA

リリース4.0で、MongoDBでも複数ドキュメントに対するACIDトランザクションが可能になりました。

しかしいままでのように効率よく開発するにはどうすればよいのでしょうか？データベースは1日で構築されたものではなく、複数ドキュメントトランザクション無しでも、何年もの間、最高レベルのデータ整合性が求められるミッションクリティカルなユースケースのために多数のアプリケーションが稼動してきているのです。

最初に、なぜたくさんの人々が複数ドキュメントトランザクションが必要だと信じているのか考えてみましょう。
リレーショナルデータモデリングの第1原則は、テーブル間でデータを正規化することです。
これは、アカウント作成をはじめとする多くの一般的なデータベースオペレーションは、多数の行と列にまたがる原始的な更新が必要だということです。

MongoDBではデータモデルが根本的に異なっています。ドキュメントモデルでは、関連のあるデータを1ドキュメント中に一緒に入れることを推奨します。MongoDBはこれまでずっと1ドキュメント単位のトランザクションをサポートしていて、このドキュメントモデルを正しく適用していれば、多くのアプリケーションでは複数ドキュメントに対してACID保証は必要ないはずです。

しかし、トランザクションはただのチェックボックスではありません。他のMongoDBの機能と同様に、トランザクションも、開発者を楽にすることを目的としています。複数ドキュメントのACID保証は、複雑なアプリケーションを実装するためのロジックを単純化します。

#### MongoDBのトランザクションの価値

MongoDBの既存の1ドキュメント単位でのオペレーションは、大多数のアプリケーションの要件を満たすトランザクション機能を提供していますが、複数ドキュメントACIDトランザクションの追加により、MongoDBのあらゆるユースケースに対して開発者が今まで以上に対応しやすくなります。snapshot isolationにより、トランザクションは一貫性のあるビューを提供し、データの一貫性を保つためのall-or-nothingの処理を保証します。リレーショナルデータベースでのトランザクションは長い歴史があるので、開発者にとってMongoDBの複数ドキュメントトランザクションはとても分かりやすいものであり、必要があれば既存のアプリケーションに追加実装するのはとても簡単でしょう。

MongoDB 4.0では、トランザクションはレプリカセット構成において機能します。MongoDB 4.2でシャード環境でもトランザクションがサポートされるように拡張予定です。（ただしSafe Harbor statement参照）トランザクションの実現にいたるまでの我々の道筋は、2015年初頭からはじまって何年にも渡り実施された、サーバーとドライバのほぼ全ての部分に埋め込まれている技術的な努力によるものです。複数ドキュメントトランザクションをレプリカセットに実装することについては、フィーチャーコンプリートしており、シャードクラスタにトランザクションを実装するために残された部分については、90%完了しています。

このブログでは、MongoDBが複数ドキュメントACIDトランザクションを追加した理由、設計目標と実装、トランザクションの特性、開発者向けのベストプラクティスについて説明します。フルマネージドの[MongoDB Atlasクラスタ](https://www.mongodb.com/cloud/atlas)を起動するか、または[ダウンロードして](https://www.mongodb.com/download-center#community)あなた自身のインフラ上で稼動させることで、すぐに試してみることができます。

#### なぜ複数ドキュメントACIDトランザクションか

2009年の最初のリリースから、MongoDBはデータベース設計の新しいアプローチを継続的に革新してきており、開発者をレガシーなリレーショナルデータベースの制約から解放してきました。慣れ親しんだプログラミング言語のAPIでアクセスできる、リッチで自然で柔軟なドキュメントに基づいた設計により、開発者はアプリケーション開発を3倍から5倍高速に構築できるようになっています。また、分散システムアーキテクチャにより、より多くのデータを処理し、ユーザーが必要とする場所に配置し、常に可用性を維持します。このアプローチにより、開発者は、あらゆる業界における極めて広い範囲のユースケースに対して、強力で洗練されたアプリケーションを開発できるようになりました。

![fig1](https://webassets.mongodb.com/_com_assets/cms/image6-trndqcoq8c.png)
Figure 1: Organizations innovating with MongoDB

サブドキュメントと配列により、関連するデータを、フラットな行と列で構成される別々のリレーショナルテーブルにまたがって分散させるのではなく、単一のリッチで自然なデータ構造の中にモデル化することができます。その結果、MongoDBの既存の単一ドキュメントでの原子性保証は、ほとんどのアプリケーションのデータ整合性の要求を満たすことができます。事実、ドキュメントモデルの豊かさとパワーを活用することで、80%から90%のアプリケーションは複数ドキュメントトランザクションを必要としないと我々は推定しています。

しかし、一部の開発者やDBAは、40年にわたるリレーショナルデータモデリングによって、複数ドキュメントトランザクションは、どのようなデータモデルの上に成り立っているかに関わり無くあらゆるデータベースに対する要求であると考えている。複数ドキュメントトランザクションは彼らのアプリケーションにおいて現在は必要ではないが、将来的に必要になるかもしれないと考える人もいます。また、複数のドキュメントにわたるACIDトランザクションのサポートが必要なワークロードも一部あります。

その結果、複数ドキュメントトランザクションが追加されることで、開発者がMongoDBでのあらゆる範囲のユースケースに対応することがいままで以上に容易になります。一部のユーザーに対しては、単に複数ドキュメントトランザクションが可能であると分からせるだけで、彼らが必要に応じてアプリケーションを進化させられるのだと確信させることができ、データベースもそれをサポートしてくれるのだと確信させることができるのです。

### データモデルとトランザクション

MongoDBの複数ドキュメントトランザクションを調べる前に、データベースで使用されるデータモデルがなぜトランザクションのスコープに影響を及ぼすのか説明します。

#### リレーショナルデータモデル

リレーショナルデータベースではエンティティのデータを複数のレコード、親子関係のテーブルにモデル化するので、
トランザクションはこれらの複数のレコードやテーブルを含むようにする必要があります。Figure 2の例は我々の顧客データベースに入っているコンタクト情報をリレーショナルスキーマでモデル化した様子を示しています。データは複数のテーブルに正規化されています。costomer, address, city, country, phone number, topics, interestsです。

どのようなやり方であれ顧客データが変更されるイベントにおいて、たとえばコンタクトが新しい仕事に移管される場合、複数のテーブルがFigure 3に示されているように "all-or-nothing" トランザクションで更新される必要があります。

#### ドキュメントデータモデル

ドキュメントデータベースで上記とは異なります。関連するデータを複数の親子関係のテーブルに分散させるのではなく、Figure 4に示すとおりドキュメントは関連するデータをリッチで型付けされた階層構造の中に一緒に含めることができ、構造の中にサブドキュメントや配列を持たせることも可能です。

MongoDBは、従来のトランザクションの特性を、ドキュメントのレベルに適用する形で提供します。Figure 5に示されているように、

#### 複数ドキュメントトランザクションが有用な箇所

複数のドキュメントに対する一連のオペレーションにACIDトランザクション保証を適用することが求められるケースがあります。バックオフィス業務での "System of Record" あるいは "Line of Business" アプリケーションが複数ドキュメントトランザクションが有効な典型例です。例としては以下のようなものがあげられます。

- ユーザーが重要なアクションを起こしたときのアプリケーションイベント処理。全ドキュメントにわたって、例えば滞納しているかどうかといったような、アカウントの状態を更新する処理。
- カスタムアプリケーションアクションのロギング。あるユーザーがあるエンティティの所有権を移譲したとき、ロギングが失敗したら書き込みも失敗しなければいけません。
- データが定義済みオブジェクトに自然にフィットするような、多対多のリレーションの場合。例えば、数十万の取引の集計によって計算され、取引が追加・変更される度に更新する必要があるポジションの情報があげられます。

MongoDBはすでに今日、これらのユースケースに対応しています。しかし複数ドキュメントトランザクションにより、さらに実現が容易になります。以前は、アプリケーションの中にトランザクション管理のような仕組みを開発者が実装する必要がありました。
データの整合性を守るには、データベースに対する更新をコミットする前に、すべてのオペレーションが成功することを保証する必要があり、もし保証できない場合はあらゆる変更をロールバックする必要があります。この複雑さにより、アプリケーション開発のスピードは落ちてしまいます。ある金融サービス業界の顧客は、複数ドキュメントトランザクションを活用することで、1000行以上のコードを削減することが出来たと報告しています。

加えて、クライアントサイドでトランザクションを実装すると、性能上のオーバーヘッドが生じる可能性があります。たとえば、既存のクライアントサイドでのトランザクションロジックから、複数ドキュメントトランザクションを利用するように移行した場合、あるグローバル規模のエンタープライズデータ統合管理製品ベンダーでは、彼らのMDMソリューションにおいてMongoDBのパフォーマンスが改善しました。スループットは90%改善し、2つのコレクションに対して6件の更新を発行するトランザクションの処理時間は60%以上削減されました。

### MongoDBでの複数ドキュメントACIDトランザクション

MongoDBでのトランザクションは、開発者がリレーショナルデータベースで慣れているトランザクションとちょうど同じように感じられるでしょう。複数のステートメントを含むことができ、似たような文法を持っていて、これまでトランザクション処理を経験したことがある人には親しみやすいものでしょう。

次に、PythonのコードでトランザクションAPIの例を示します。

```
with client.start_session() as s:
    s.start_transaction()
    collection_one.insert_one(doc_one, session=s)
    collection_two.insert_one(doc_two, session=s)
    s.commit_transaction()
```

Javaでの例は以下のようになります。

```
try (ClientSession clientSession = client.startSession()) {
    clientSession.startTransaction();
    collection.insertOne(clientSession, docOne);
    collection.insertOne(clientSession, docTwo);
    clientSession.commitTransaction();
}
```

これらの例で示されているように、トランザクション処理においても通常のMongoDBのクエリ言語の文法がそのまま使用可能で、トランザクションが複数ドキュメントにわたって実行されているかどうかに関わらず一貫した形で実装されています。

以下の、トランザクションブロックのコードは、MongoDBでの書き方とMySQLでの書き方を比較したものです。複数ドキュメントトランザクションが、伝統的なリレーショナルデータベースの経験者に親しみやすいことが分かるでしょう。

#### MySQL

```
db.start_transaction()
    cursor.execute(orderInsert, orderData)
    cursor.execute(stockUpdate, stockData)
db.commit()
```

#### MongoDB

```
s.start_transaction()
    orders.insert_one(order, session=s)
    stock.update_one(item, stockUpdate, session=s)
s.commit_transaction()
```

Snapshot Isolationをとおして、トランザクションは一貫したビューを提供し、データの一貫性を保つall-or-nothingの実行を強制します。
トランザクションは、単一コレクションまたは複数コレクション、単一データベースまたは複数データベースのいずれかに格納されている、複数ドキュメントを扱うオペレーションに対して適用可能です。トランザクションが不要な場合の処理に対しては、今回のトランザクション機能追加によるオーバーヘッドは生じません。

処理実行中、あるトランザクションはそれ自身の未コミットの書き込みを読むことが出来ますが、それら未コミットの書き込みは、他のトランザクションからは見られません。未コミットの書き込みは、コミットされるまでセカンダリにレプリケーションされることはありません。ひとたびトランザクションがコミットされたら、その内容はレプリケーションされ、原子的にすべてのセカンダリに対して反映されます。

アプリケーションからトランザクションのオプションとして、何台のノードに変更を確定させてからクライアントに正常応答を返すかを決める Write Concern を指定します。未コミットの書き込み情報は、プライマリのみに存在します。

MongoDB 4.0でのトランザクション機能を活用することで、新しい snapshot read concern は、読込のみのトランザクション内で実行されるクエリやaggregationに関して、プライマリレプリカ上で単一の分離されたsnapshotに対して実行されるように保証することができます。その結果、同時実行操作によってデータが同時に変更されているかどうかに関係なく、データの一貫したビューがクライアントに返されます。スナップショット読み取りは、getMoreコマンドを使用してバッチでデータを返す操作に特に役立ちます。

MongoDB 4.0より前ですら、典型的なMongoDBのクエリはWiredTigerのsnapshotを活用していました。従来のMongoDBクエリのsnapshotとトランザクション環境におけるsnapshot readの違いは、トランザクション環境におけるsnapshot readではクエリの期間中ずっと同一のスナップショットを使うという点です。一方で従来のMongoDBクエリのsnapshotは、yield pointで最新のsnapshotに切り替わる可能性があります。

#### Snapshot Isolationと書き込み競合

あるドキュメントを変更するとき、トランザクションは処理完了までの間、他の変更に対して当該ドキュメントをロックします。すでに他のトランザクションがロックを保持しているなどの理由で当該ドキュメントに対してロックを取得できない場合は、当該トランザクション処理は5ms後にwrite conflictによりアボートします。

しかし、複数ドキュメントトランザクションの範囲外において従来型のMongoDBの書き込みが他のトランザクションに保持されているドキュメントを更新しようとした場合、その従来型の書き込みはトランザクション完了までブロックされます。従来型の書き込みは、[$maxTimeMS](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/index.html#metaOp._S_maxTimeMS)のタイムアウトまで、バックオフロジックにもとづいてずっとリトライし続けます。4.0より前のバージョンであっても、すべての書き込みはストレージレイヤーにおいてはWiredTigerトランザクションとなり、write conflictが発生する可能性があります。同じロジックが実装されていて、クライアントサイドでwrite conflictに対応する必要がないようになっています。

読込は、書き込みのようなロックは必要としません。あるトランザクションで未コミットの書き込みがあるドキュメントは、他のオペレーションから読むことができます。そしてもちろん、これらのオペレーションはコミット済みの値のみを読むことができ、未コミットの状態は読みません。★★★（この読み込みは同一トランザクション中のことを言っているのか、外部のことを言っているのか？）

write conflictを発生させる可能性があるのは書き込みだけです。読込は、snapshot isolationで期待される動作の通り、あるドキュメントに対して他のオペレーションによる変更を妨げません。ドキュメントに対して書き込みが行われない限り、変更はwrite conflictとして顕在化することはありません。さらに、ある項目を更新前と同じ値にセットするなどのno-op更新は、ストレージエンジンに到達する前に最適化が働いて削除されるので、write conflictを発生させることはありません。write conflictの検出を保証するためには、カウンタをインクリメントするなどのオペレーションを実行することになります。

#### トランザクションのリトライ

MongoDB 4.0ではエラーラベルという概念が導入されました。一時的なトランザクションエラーのラベルは、エラーに直面したアプリケーションに対して、ネットワークエラーからwrite conflictまで、エラーが一時的なものである可能性があり、トランザクションを最初から再実行しても安全であるということを通知します。パースエラーなどの永続的なエラーは、トランザクションを再実行したとしても成功することはないので、一時的なトランザクションエラーラベルは付与されません。

MongoDBのコアバリューの1つは、その高可用アーキテクチャです。これらのエラーラベルにより、ネットワークの瞬断や一時的なノード障害があったとしても、アプリケーションが自動復旧しやすくなります。複数ドキュメントに対するトランザクションを保証し、常時稼動し続ける必要があるユースケースも犠牲にすることはありません。

#### トランザクションに関するベストプラクティス

上述したように、MongoDBの単一ドキュメントの原子性保証は、80から90%のアプリケーションのトランザクションに関するニーズを満たすはずです。単一ドキュメントのトランザクションは、データ一貫性に対する要求を満たすのに、依然として推奨される手法です。本当に複数ドキュメントトランザクションを必要とするオペレーションに対しては、開発者が注意すべきいくつかのベストプラクティスがあります。

長時間にわたるトランザクションを実行しようとしたり、あるいは非常に大量のオペレーションを単一のトランザクション中で実行しようとすると、WiredTigerキャッシュに対して高負荷を与える結果に繋がります。もっとも古いスナップショットが作成された後のすべての書き込みの状態がキャッシュ上で管理されているためです。トランザクションは、実行中同じスナップショットを使用するので、新たな書き込みはトランザクションの期間中キャッシュに蓄積されていきます。これら蓄積された書き込みは、古いスナップショットで実行中のトランザクションがコミットまたはアボートするまでフラッシュできません。コミットまたはアボートされた時点でトランザクションはロックを解除し、WiredTigerはスナップショットをキャッシュ上から立ち退かせることができます。予測可能なレベルのデータベースパフォーマンスを維持するために、開発者は次の点を考慮する必要があります。

1. デフォルトでは、MongoDBは60秒以上続いた複数ドキュメントトランザクションを自動的にアボートします。サーバに対する書き込みの容量が小さい場合、この実行時間を長くチューニングすることも可能ということに注意が必要です。タイムアウトに対処するためには、トランザクションは設定したタイムアウト時間内で実行できるよう小さく分割する必要があります。また、トランザクション内で高速なデータアクセスを可能にするため、適切なインデックスカバレッジでクエリパターンが最適化されていることを確認する必要があります。

2. トランザクション内で読み取ることができるドキュメントの数について制限はありません。ベストプラクティスとして、トランザクション中で1000以上のドキュメントを変更するべきではありません。1000を超えるドキュメントを変更する必要があるオペレーションの場合、開発者はトランザクションを小さな単位に分割するべきです。

3. MongoDB 4.0では、トランザクションは単一のoplogエントリとして表現されます。したがって16MBというサイズ制限があります。updateオペレーションは更新の差分（つまり変更されたもの）のみを保存しますが、insertはドキュメント全体を保存します。結果として、トランザクション内のすべてのステートメントのoplogの組み合わせは16MB未満でなければなりません。この制限を越えると、トランザクションはアボートされ、完全にロールバックされます。したがって、トランザクションは、16MB以下で表現できるより小さな一連の操作に分割される必要があります。

4. トランザクションがアボートすると、ドライバに例外が返され、トランザクションは完全にロールバックされます。開発者は、一時的なネットワーク障害やプライマリの選定中などの一時的な例外でアボートしたトランザクションをキャッチして、リトライさせるようなアプリケーションロジックを追加する必要があります。retryable write機能を使うと、MongoDBドライバは自動的にトランザクションのコミットステートメントを再実行します。

5. DDLオペレーション（インデックス作成やデータベースの削除など）は、同一ネームスペースで実行中のトランザクションが存在する場合にはブロックされ、保留となります。DDLオペレーションが保留中に、新たに当該ネームスペースにアクセスしようとするすべてのトランザクションは、ロックを獲得することができず、新しいトランザクションはアボートされます。

[MongoDBのマニュアル](https://docs.mongodb.com/master/core/transactions/)で、複数ドキュメントトランザクションに関するすべてのベストプラクティスを確認できます。

#### トランザクションと、それによるMongoDBでのデータモデリングに対する影響

トランザクションが追加されたからと言って、MongoDBがリレーショナルデータベースになるわけではありません。たくさんの開発者がドキュメントモデルはリレーショナルモデルより優れていることを今日まで経験してきたはずです。

MongoDBのデータモデリングに関するすべてのベストプラクティスは、複数ドキュメントトランザクションや、完全なJOIN（[$lookup aggregationパイプラインステージ](https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/index.html)を使用するもの）などの機能を使う場合にも、適用可能です。実際には、エンティティに関連するすべてのデータは、単一のリッチなドキュメント構造に格納するべきです。リレーショナルテーブル用に構造化されたデータをMongoDBに移行するだけでは、MongoDBの自然で、高速で、柔軟なドキュメントモデルや、分散システムアーキテクチャの利点を活用することはできません。[RDBMS to MongoDB Migration Guide](https://www.mongodb.com/collateral/rdbms-mongodb-migration-guide) では、アプリケーションをリレーショナルデータベースからMongoDBに移行するためのベストプラクティスについて説明しています。

### トランザクションへの道筋

我々のトランザクションへの道筋は、3年以上前にWiredTigerストレージエンジンを統合したときから始まり、複数年にわたるエンジニアリングの努力をあらわしているものです。ストレージレイヤそのものから、レプリケーションコンセンサスプロトコル、シャーディングアーキテクチャに至るまで、我々はプラットフォームのほぼすべての部分に基礎を築いてきたのです。我々は、きめ細かな一貫性と耐久性保証の実装、グローバルロジカルクロックの導入、クラスタのメタデータ管理のリファクタリングなど多くのことを行ってきました。そして我々は、ドライバによって完全に活用可能なAPIを通して、これらの改善を公開してきました。我々は複数ドキュメントトランザクションをレプリカセットに持ち込むことについて、フィーチャーコンプリートしました。またシャードクラスタでトランザクションを実現するために必要な残りの機能について90%完了しました。

Figure 6は、MongoDBで複数ドキュメントトランザクションを可能にした主要なエンジニアリングプロジェクトのタイムラインで、2018年6月現在の状況を示しています。これらのプロジェクトすべての根底にある主要な設計目標は、それらの実装がMongoDBの主なメリット、つまりドキュメントモデルの力と分散システムのメリットを損なわないこと、さらに、複数ドキュメントトランザクションが不要なワークロードに対しては性能に影響をおよぼさないことでした。

### 結論

MongoDBはモダンなアプリケーションのためのデータベースとして地位を確立してきました。ドキュメントデータモデルはリッチで、自然で、柔軟性があり、慣れ親しんだドライバによってアクセスできるドキュメントにより、開発者はアプリケーションを3倍から5倍高速に開発できるようになっています。その分散システムアーキテクチャにより、さらに多くのデータを処理し、ユーザーが必要な場所にデータを配置し、常時稼動を続けさせることが可能になります。MongoDBの既存の単一ドキュメントに対する原子的なオペレーションは、大多数のアプリケーションにおける整合性要件を満たすトランザクションを提供します。MongoDB 4.0における複数ドキュメントACIDトランザクションの追加によって、開発者はユースケースに完全に対応することがいままで以上に容易になりますが、多くの場合には、それが利用可能であることを知るだけで大きな安心を得られることでしょう。

[複数ドキュメントトランザクションのWebページ](https://www.mongodb.com/transactions)を見てください。トランザクション機能を実装したMongoDBエンジニアの話を直接聞くことができ、サンプルコードスニペットを見ることができ、使い始めるために必要な主要リソースにアクセスできます。フルマネージドで、オンデマンド型の [MongoDB Atlas クラスタ](https://www.mongodb.com/cloud/atlas)を立ち上げることで、または[ダウンロードして](https://www.mongodb.com/download-center#community)あなた自身の環境で実行することで、すぐにMongoDB 4.0を使い始めることができます。

もしあなたがMongoDB 4.0での新機能についてもっと知りたければ、[ガイドをダウンロードしてください](https://www.mongodb.com/collateral/mongodb-40-whats-new)。

### \* Safe Harbour Statement

This blog contains “forward-looking statements” within the meaning of Section 27A of the Securities Act of 1933, as amended, and Section 21E of the Securities Exchange Act of 1934, as amended. Such forward-looking statements are subject to a number of risks, uncertainties, assumptions and other factors that could cause actual results and the timing of certain events to differ materially from future results expressed or implied by the forward-looking statements. Factors that could cause or contribute to such differences include, but are not limited to, those identified our filings with the Securities and Exchange Commission. You should not rely upon forward-looking statements as predictions of future events. Furthermore, such forward-looking statements speak only as of the date of this presentation.

In particular, the development, release, and timing of any features or functionality described for MongoDB products remains at MongoDB’s sole discretion. This information is merely intended to outline our general product direction and it should not be relied on in making a purchasing decision nor is this a commitment, promise or legal obligation to deliver any material, code, or functionality. Except as required by law, we undertake no obligation to update any forward-looking statements to reflect events or circumstances after the date of such statements.
